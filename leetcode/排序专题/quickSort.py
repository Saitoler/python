# -*- coding: utf-8 -*-


# ********************** 快速排序 ****************** #


# 快排过程参考：https://blog.csdn.net/elma_tww/article/details/86164674



# 利用分治法的思想，利用递归来最终实现快速排序 
# 主要思路：
#   1. 每一轮选取一个基础值，将小于基础值的数据，都放在基础值的左侧，大于基础值的数据，都放在基础值的右侧
#      一轮完成后得到的结果是，[小于基础值的数据集，基础值，大于基础值的数据集] 这样形式的一个数组
#   2. 利用递归思想，对于左侧数据集、右侧数据集再分别进行递归排序，直至两边的数据集中都只包含一个元素，此时
#      表明所有的数据都已经有序了。
# 每一轮中的具体实现：
#  1. 选取一个基准值，一般来说是当前数组的第一个元素
#  2. 从数组右侧开始搜索，一旦找到小于基准值的数据，就放置在左侧区域中当前左侧位置处(i 所在地)
#  3. 从数组左侧开始搜索，一旦找到大于基准值的数据，就放置在右侧区域中当前右侧位置处(j 所在地)
#  重复以上步骤直到左指针和右指针相遇，说明所有元素都已遍历过了，就将基准值放置在当前所指的位置-- i, j 相遇的位置

# 时间复杂度： O(nlog2^n)
# 空间复杂度： O(nlog2^n)


# 具体代码如下：

def quickSort(nums, left, right):
	if left < right:
		# 基准值记录
		base = nums[left]
		# 定义左，右指针，来记录左右扫描区域的当前位置
		i, j = left, right

		while i<j:
			# 先从数据组的最右侧向左扫描，如果数据一直大于基准值，则继续左移
			while (i<j and nums[j]>base):
				j -= 1
			# 上面的 while 循环 结束时的 j 值对应的元素是 小于等于基准值的，将该元素放在左侧区域中
			nums[i] = nums[j]

			# 再从数据组的最左侧向右扫描，如果数据一直小于等于基准值，则继续右移
			while (i<j and nums[i]<= base):
				i += 1
			# 上面的 while 循环结束时的 i 值对应的元素是大于基准值的，将该元素放在右侧区域中
			nums[j] = nums[i]

		# 上面的整体 while 循环结束时，说明i,j 已经相遇，这一轮计算已经结束，则将 base 基准值放在中间位置，即i,j 相遇的地方
		nums[i] = base

		# 对基准值的左侧、右侧区间数据集分别再进行快排操作
		quickSort(nums, left, i-1)
		quickSort(nums, i+1, right)

	# left=right 时说明当前子集中只剩一个元素了，已经是有序的了，直接 return 结束即可
	else:
		return


if __name__ == "__main__":

	nums = [2, 1, 45, 3, 56, 34, 78, 2, 90]
	quickSort(nums, 0, len(nums)-1)

	print(nums)

